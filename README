The Managed Build Process

This repository serves as a starting point you can use to create a managed
build directory, allowing you to perform builds against a WR Pulsar Linux
install, with change tracking between builds.

You need git 1.9.3 or newer, with submodule support. (The git provided in an
oe-core build tools tarball may not have submodule support.)

Directories:

The following subdirectories are used by the managed build process.
Only the /scripts subdirectory is created as part of the initial
clone, the rest are created by the scripts when needed.

/buildhistory 	- submodule - buildhistory generated by the YP build system
/deploy		- submodule - generated package feeds, sources, images and sdks
/project	-           - the configured project directory
/scripts		    - scripts for creating and managing the install
/sstate-cache 	- submodule - sstate-cache information generated by the build
/tmp 		- submodule - temporary directory, only logs are preserved
/prdb 		- submodule - generated PR server db directory
/src 		- submodule - the project source code tarball directory

To set up a new managed build project, first create an overall projects
directory.  (This step is optional.)

  $ mkdir pulsar-distro
  $ cd pulsar-distro

Clone the meta-project starting point.  (Be sure to use the YP branch.)

  $ git clone --branch=master .../mbp my-project
  $ cd my-project
  [optionally: change branches]
  $ git checkout -B fido

Configure the project.

  $ ./scripts/configure-project.sh -n ${BSP_NAME} -p $PRSERVER_PORT -j $JOBS \
    -b $BRANCH -u 1 -s $SRC_BASEURL
  $./scripts/configure-project.sh -h will print the usage menu.

Now edit the project/build/conf/local.conf and project/build/conf/bblayers.conf
files as necessary.

  $ vi project/build-${BSP_NAME}/conf/local.conf
  $ vi project/build-${BSP_NAME}/conf/bblayers.conf

After configuring it is recommended that you commit the setup.
This creates a checkpoint that you can restore to later.

  $ ./scripts/commit-project.sh "Initial project configuration"

The project can be built using standard Yocto Project build practices.
  $ . ./project/init-${BSP_NAME}-env project/build-${BSP_NAME}
  $ bitbake cube-dom0

  # Return to the main directory
  $ cd .../my-project

Once you have built the software successfully, you will want to deploy it
to the 'deploy' directory and then checkpoint your project again.

  $ ./scripts/deploy-project.sh -n ${BSP_NAME}
  $ ./scripts/commit-project.sh "Commit message here"

If you upgrade to a newer version of Poky or any of your other layers, you
will need to tell the system to reindex the layer components.  The 
upgrade-project.sh script much be used for that.

  $ (cd project ; git pull)
  $ ./scripts/upgrade-project.sh

The pulsar-build.sh script is a wrapper for the above configure, build and
deploy the project operations.

  $ ./scripts/pulsar-build.sh -n ${BSP_NAME} -p $PRSERVER_PORT -j $JOBS \
      -b $BRANCH -c $CONTAINER -u 1 -s $SRC_BASEURL
  $./scripts/pulsar-build.sh -h will print the usage menu.

The system has now been upgraded to the latest "version".
You can then build the upgraded project, deploy and commit your changes.
The steps above, the build, deploy and commit example, can be used.

Note, many components of the system get hard coded path values.  If this
project is moved to another location or machine, you must update the 
project to the new location.  (If you move an existing project you may need
to remove the tmp/work, and clear the project/layers directory.)

The following example shows how to use refresh-project.sh when checking out
the project from another location:

  $ git clone --branch fido --recursive <path>/my-project
  $ cd my-project
  $ ./scripts/refresh-project.sh

Once updated, it's suggested that you commit the project.  You can then build
the updated project, deploy and commit your changes.  Again see the steps
above for examples.


How to reset the 'tmp' directory:

If you have a failed build, you may need to clean the tmpdir.  This is a 
fairly standard workflow when working with the Yocto Project build system.

The easiest way to do this is:

  $ cd my-project
  $ rm -rf tmp/*   (note do NOT rm -rf tmp, as it removes the .git info)
  $ cd tmp
  $ git reset --hard

How to revert to a previous checkpoint (commit-project):

In some cases, it may be necessary to backup to a previous checkpoint.  Each
time you use commit-project, you create a checkpoint that can be restored.

The easiest method for moving to a checkpoint is:

   $ cd my-project
   $ git log    (capture the commit ID of the checkpoint you want to go to)
   $ scripts/reset-proejct.sh <commit id>

Note, reset-project.sh uses 'git reset --hard'.  So future commits, and other
pending changes may be lost.  You should use standard git practices (tags, 
branches, etc) in order to move back to checkpoints if you also plan to move
back forward in the tree.

sample local.conf
-----------------

After cloning the relevant layers, local.conf should be set up to
properly manage the build. In particular the PR server, the
archiver and ABI configuration must be correct. What follows is
an example of those settings:

## You need the PRSERVER for package bumps.
PRSERV_HOST = "localhost:8989"

# Assumption is any changes to the below items should not require a rebuild
# of dependent items.  If it doesn, this will have to be managed externally
# of this configuration.  Toolchain changes are most likely an issue.
SIGGEN_EXCLUDERECIPES_ABISAFE += " \
        binutils-cross-\${TARGET_ARCH} \
        gcc-cross-\${TARGET_ARCH} \
        gcc-runtime \
        glibc \
        libgcc \
        linux-libc-headers \
        rpm-native \
        coreutils \
        busybox \
        util-linux \
        e2fsprogs \
"
# Trust us, we don't want changes here to cause rebuilds!
# If we change any of these values we only want new builds to be
# affected anyway -- otherwise everything invalidates.
BB_HASHBASE_WHITELIST_append = " \
        FULL_OPTIMIZATION \
        DEBUG_OPTIMIZATION \
        DEBUG_BUILD \
        DEBUG_FLAGS \
"

# Force current and future toolchains to keep the same version
# Otherwise a toolchain upgrade will force all new packages,
# due to a change in dependency versions...
# we don't want that behavior
SDK_BINUTILS_PV_forcevariable  = "sdk"
SDK_GCC_PV_forcevariable       = "sdk"
SDK_GLIBC_PV_forcevariable     = "sdk"
SDK_LINUXLIBC_PV_forcevariable = "sdk"
SDK_GDB_PV_forcevariable       = "sdk"

# Enable the archiver
USER_CLASSES += "archiver"

ARCHIVER_MODE[src] = "original"
ARCHIVER_MODE[diff] = "1"
ARCHIVER_MODE[dumpdata] = "1"
ARCHIVER_MODE[recipe] = "1"

ARCHIVER_SRC_NAME = "${@"".join(d.getVar('PN', True).split(d.getVar('MLPREFIX', True) or "NOPREFIX")) + '-' + d.getVar('PKGV', True).replace('-', '+') + '-' + d.getVar('PKGR', True)}"
ARCHIVER_OUTDIR_forcevariable = "${ARCHIVER_TOPDIR}/${@(d.getVar('MLPREFIX', True) or "").replace("-", "_")}${@(d.getVar('PACKAGE_ARCH', True) or "").replace("-", "_")}/${ARCHIVER_SRC_NAME}"

